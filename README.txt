Donald Pagan
Jonathan Chen
machines:	cs352-5, cs352-6
user:		csuser
password:	cs198352

	The program was organized to separate the core functions and processes of the program from the program's interface. cs352proxy.c held all of the core functions, and cs352proxy.h had all of the include statements, typedefs and function declarations, and acted as an interface for main() to access the functions of cs352proxy.c and all of the other library functions and structures.
	
	main() has been rewritten since part 1 to accommodate for the configuration file. After it reads the configuration file, it then starts the threads to listen to the devices and connections, installs a signal handler to handle an alarm set to the the time in which the proxy must broadcast the link-state packet, and then main() enters an infinite server loop, listening for TCP connection requests, and creating a new thread to service those connections. Several new functions are defined to handle every single packet type, but, since not all of them are implemented yet, they simply return without doing anything. The core concept of the code is the use of void pointers and buffers to dereference fields in buffers whose contents depend on the context. Casting buffer pointers as structure pointers definitely facilitates information gathering and manipulation.
	
	I, Donald, worked on the cases for the main function, and wrote the open_listenfd() and open_clientfd() functions, whose fundamental ideas can be found in the textbook "Computer Systems: A Programmer's Perspective" in chapter 11, which covers network programming. Jon Chen worked on the functions that the threads individually invoke, which read packets and, depending on which device from which they originate, either encapsulates or de-encapsulates the packet and writes it to the other device.
	
	Since handing in part 1, I, Donald, faced many problems in editting the program to make the proxy properly send and receive packets. The first problem was that the tap device was not receiving any information. Johnathan discovered that this was because we were pinging to the I.P. address of the tap device, 192.168.1.1, and not to an I.P. address that would be routed through the tap device. From then on, we pinged to 192.168.1.2.
	
	The second problem, which I tackled for a few days, was from assuming that the two-octet field of the ethernet frame header was valued at the length of the frame payload, and from assuming that the frame payload properly encapsulated IPv4; this was not the case, as the field was consistently valued above 0x0800, and the values of the locations where there would be the IPv4 version number, length and protocol of the segment were wrong. After researching Ethernet, I discovered that this two-octet field is called Ethertype, and denotes which protocol is encapsulated in the frame payload. At first, Ethertype was consistently valued at 0x0806, which, according to the Wikipedia page on Ethertype, indicated that the payload encapsulated Address Resolution Protocol (ARP). This implies that there was a problem with the tap device in properly encapsulating IPv4. I spent several days looking through Stack Overflow threads, OpenVPN documentation and the man pages of the programs ip and ifconfig, and found how to turn ARP off on a tap device. After doing so, the tap device stopped encapsulating ARP and started encapsulating... IPv6, which I knew because the usual location of the IPv4 version number was valued at 6. I found out how to set a device to only use IPv4, and tested the program.
	
	The third problem was that, although the first packet was properly read and interpretted, the all of the packets after that had wrong information. This problem I was able to solve after about two hours of debugging. In the first rio_read() call, 98 bytes were immediately read from the tap device and stored in a buffer in a rio_t structure associated with the tap device. 14 bytes were extracted from the buffer to read the Ethernet frame header, and 20 bytes were taken for the IPv4 packet header, from which I found that the total length of the IP datagram was 84 bytes, the default length of an IP datagram for ping. I extracted the rest of the 64 bytes of the IP datagra, plus 4 bytes of the Ethernet frame footer, from the buffer. And there was the problem: 98-84-4=-4; the Ethernet frame checksum was not there. After editting the length parameter of the final read call in tap_handler() when I read the rest of the IP datagram, the proxy on bothe the sending and receiving ends printed the correct information concerning the Ethernet frame header, the IPv4 packet header, and, if the protocol number of the IPv4 packet header indicates that the segment is an ICMP segment, the ICMP header information as well. Both proxies print accurate information of each IP/ICMP datagram as it is transmitted through the proxies, including the sequence numbers of each packet.
	
	The final problem was that, after the receiving proxy writes the IP/ICMP datagram to the tap device, the receiving host does not send an echo reply. The tap device is not passing the IP/ICMP datagram to the network stack of the computer, because, if it did, then the machine would pong the sending host. At this point, I gave up trying to fix part 1, because I spent about a month just trying to make part 1 work perfectly without even beginning part 2. Eventually, I found out that I had to send the whole Ethernet frame, not just the IP/ICMP datagram, and that ARP is necessary to derive the receiving MAC address. After I fixed the code to account for this, ping worked great, but the program crashes randomly at polling and locking. I discovered that this was due to the fact that poll() and fcntl() can be interrupted by signals, which, if unaccounted for, can lead to bugs. I defined Wait() and Lock() for thread-safe, signal-safe polling and file-locking, and now it pings indefinitely. Part 1 is finished.
	
	I, Donald, had one week left for part 2. Since part 2 had to do with handling packet information, I decided to define structures in proxy.h so as to facilitate dereferencing information in packets. Most of the code in packet-handling functions deal with just reading or writing structures that are dereferenced by a buffer pointer. I used code from Richard Stevens' classical text "UNIX Network Programming" to define a helper function for signal handling, and I use it in main() to define signal handlers that are necessary for termination and periodic broadcasts. leave_handler() was a signal handler for termination signals, and would broadcast a leave packet before shutting down connections and terminating the program. Link_State_Broadcast() was a signal handler for the signal SIGALRM that would periodically construct and broadcast a link-state packet. I also revised the connection functions from the client side and the server side to commence the initial join link-state packet exchange after the completion of the TCP/IP 3-way handshake.
	
	I entrusted John with writing the procedures for adding and removing members from the membership list, which we implemented as a hash-table designed by uthash.h. I revised the mutual exclusion procedures to conform to the writer-preferential solution to the Readers-Writers Problem, and defined them in helper functions (readBegin(), readEnd(), writeBegin(), writeEnd()) so that they can be used easily throughout the program. John was also responsible for constructing the timers to remove peers from the membership list if their link timeouts expired.
